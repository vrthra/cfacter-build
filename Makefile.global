#  The general variables that may be modified from the environment. The most
#  important is the arch changes whether a native compiler or a cross-compiler
#  is built.

rootdir:=$(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))

arch=i386
# -----------------------------------------------------------------------------
# These are the projects we are currently building. Where possible, try to
# follow the $project-$ver format, if not, use the boost example.

projects=
# -----------------------------------------------------------------------------
#  These are arch dependent definitions for native and cross compilers.
#  These should be moved to their own files, and included with
#  `include Makefile.$(arch)` if ever the number of definitions increases
#  further or any generic makefile rules are added for one of the platforms.
#  Similarly, add `include Makefile.$(sys_rel)`
#  and `include Makefile.$(arch).$(sys_rel)` if necessary.

define mytarget
$(if $(findstring sparc,$(1)),sparc-sun-solaris,i386-pc-solaris)$(solaris_version)
endef

# need the label for making tar balls.
installlabel=pl-build-tools
installroot=/opt/$(installlabel)
prefix=$(installroot)/$(arch)
target=$(call mytarget,$(arch))
ifeq (sparc,${arch})
	sysroot=--with-sysroot=$(prefix)/sysroot
else
	sysroot=
endif
# -----------------------------------------------------------------------------
# The URL from where we get most of our sources.
sourceurl=http://enterprise.delivery.puppetlabs.net/sources/solaris
toolurl=https://pl-build-tools.delivery.puppetlabs.net/solaris
# -----------------------------------------------------------------------------
#  A few internal definitions. sys_rel decides whether
#  we are building solaris 10 or solaris 11. Note that if we set sys_rel
#  to 11 on a solaris 10 machine, gcc generates a cross compiler,
#  (and v.v. for s11).

sys_rel:=$(subst 5.,,$(shell uname -r))
solaris_version=2.$(sys_rel)

# how we want to get our compiler suite?
# use `gmake getcompilers=fetch __` to get it from the precompiled tarballs in
# remote repo. Use `gmake getcompilers=make __` to make use of locally
# compiled suite.

getcompilers:=make
export getcompilers

# The source/ directory ideally should not contain arch dependent files since
# it is used mostly for extracting sources. On the other hand, our builds have
# separate directories for each $arch
builds=$(addprefix build/$(arch)/,$(projects)) 
installs=$(addprefix install/$(arch)/,$(projects)) 
source=$(addprefix source/,$(projects))
fetched=$(addprefix fetched/,$(projects))

# our touch files, which indicate that specific actions have completed
# without errors.

define get_x
get_+=$(addsuffix .tar.gz,$(addprefix fetched/,$(1)))
endef
define get_xx
get_+=$(addprefix source/,$(1))
endef

define checkout_x
checkout_+=$(addsuffix /._.checkout,$(addprefix source/,$(1)))
endef
define patch_x
checkout_+=$(addsuffix /._.patch,$(addprefix source/,$(1)))
endef
define config_x
config_+=$(addsuffix /._.config,$(addprefix build/$(arch)/,$(1)))
endef
define make_x
config_+=$(addsuffix /._.make,$(addprefix build/$(arch)/,$(1)))
endef
define install_x
config_+=$(addsuffix /._.install,$(addprefix install/$(arch)/,$(1)))
endef

define standard_x
$(eval $(call get_x,$(1)))
$(eval $(call checkout_x,$(1)))
$(eval $(call patch_x,$(1)))
$(eval $(call config_x,$(1)))
$(eval $(call make_x,$(1)))
$(eval $(call install_x,$(1)))
endef

toolchain_=$(addsuffix ._.cmakeenv, source/$(arch)/)

# -----------------------------------------------------------------------------
ar=/usr/ccs/bin/ar
tar=/usr/sfw/bin/gtar
gzip=/bin/gzip
bzip2=/bin/bzip2
patch=/bin/gpatch
rsync=/bin/rsync
wget=wget -q -c --no-check-certificate
git=git

as=$(prefix)/$(target)/bin/as
ld=$(prefix)/$(target)/bin/ld
cmake=$(installroot)/i386/bin/cmake
# -----------------------------------------------------------------------------
# $mydirs, and the make rule make sure that our directories are created before
# they are needed. To make use of this, add the directory here, and in the
# target, use `<target>: | <dirname>` incantation to ensure that the directory
# exists. (Notice the use of '|' to ensure that our targets do not get rebuilt
# unnecessarily)

sysdirs=$(installroot)/$(arch)/sysroot
mydirs=source build install fetched $(source) $(builds) $(installs) \
			 build/$(arch)  source/$(arch) \
			 source/$(arch)/root $(sysdirs) \
			 source/cfacter build/$(arch)/cfacter
# -----------------------------------------------------------------------------
# some trickery to use array path elements
e:=
space:=$(e) $(e)
path=$(prefix)/bin \
		 $(prefix)/$(target)/bin \
		 $(installroot)/$(arch)/bin \
		 /usr/ccs/bin \
		 /usr/gnu/bin \
		 /usr/bin \
		 /bin \
		 /sbin \
		 /usr/sbin \
		 /usr/sfw/bin \
		 /usr/perl5/5.8.4/bin \
		 /opt/csw/bin

# ensure that the path is visible to our build as a shell environment variable.
export PATH:=$(subst $(space),:,$(path))


gccpath=$(installroot)/$(arch)
gccnativepath=$(installroot)/i386
cmakepath_=$(gccpath)/bin \
          /usr/ccs/bin \
          /usr/gnu/bin \
          /usr/bin \
          /bin \
          /sbin \
          /usr/sbin \
          $(gccnativepath)/bin \
          /usr/perl5/5.8.4/bin

cmakepath=PATH=$(subst $(space),:,$(cmakepath_))

